//‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
// üé¥ùõ´ùëàùëÖùõ©ùõÆùõ• ‚Äî ùëøùõ≠ùë´üé¥
// Commandes de mention / TAG ‚Äî Ton Majordome
//‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

import { createWriteStream } from 'fs';
import pkg from "@whiskeysockets/bailey";
const { downloadMediaMessage } = pkg;
import configManager from '../utils/manageConfigs.js';

const BOT_SIGNATURE = 'üé© Votre humble serviteur ‚Äî üé¥ùêÉùõØùêï ·¨Å ùõ´ùëàùëÖùõ©ùõÆùõ•üé¥ üé©';

export async function tagall(message, client) {
    const jid = message.key.remoteJid;
    if (!jid.includes('@g.us')) return client.sendMessage(jid, { text: 'Veuillez excuser cette requ√™te, mais les mentions sont strictement r√©serv√©es aux rassemblements de ce cercle distingu√©.' });

    try {
        const group = await client.groupMetadata(jid);
        const participants = group.participants.map(p => p.id);

        const mentionsText = participants.map(u => `‚Ä¢ Monsieur/Madame @${u.split('@')[0]}`).join('\n');
        const tagMessage = `
> ‚ï≠‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚ïÆ
> ‚îÇ    üé¥HONORED CALL TO ALLüé¥         ‚îÇ
> ‚ï∞‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚ïØ

Avec tout le respect qui vous est d√ª, @${message.key.participant?.split('@')[0] || 'Votre Excellence'} pr√©sente l‚Äôinvocation :

${mentionsText}

${BOT_SIGNATURE}`.trim();

        await client.sendMessage(jid, { text: tagMessage, mentions: participants });
    } catch (err) {
        console.error("Erreur lors de l'invocation de tous les membres :", err);
    }
}

export async function tagadmin(message, client) {
    const jid = message.key.remoteJid;
    if (!jid.includes('@g.us')) return client.sendMessage(jid, { text: 'Ah, je crains que cette commande ne soit disponible qu‚Äôau sein d‚Äôun cercle privil√©gi√©‚Ä¶' });

    const botNumber = client.user.id.split(':')[0] + '@s.whatsapp.net';
    try {
        const { participants } = await client.groupMetadata(jid);
        const admins = participants.filter(p => p.admin && p.id !== botNumber).map(p => p.id);

        if (!admins.length) return client.sendMessage(jid, { text: 'Il semblerait qu‚Äôaucun membre de distinction ne soit pr√©sent √† l‚Äôinstant.' });

        const text = `üé© *Les honorables administrateurs sont pri√©s de se manifester:*\n${admins.map(u => `‚Ä¢ Monsieur/Madame @${u.split('@')[0]}`).join('\n')}`;
        await client.sendMessage(jid, { text, mentions: admins });
    } catch (err) {
        console.error("Erreur lors de l'invocation des administrateurs :", err);
        await client.sendMessage(jid, { text: 'Une malencontreuse erreur a emp√™ch√© l‚Äôinvocation des administrateurs.' });
    }
}

export async function tag(message, client) {
    const jid = message.key.remoteJid;
    if (!jid.includes('@g.us')) return client.sendMessage(jid, { text: 'Cette op√©ration est strictement r√©serv√©e aux cercles distingu√©s.' });

    try {
        const group = await client.groupMetadata(jid);
        const participants = group.participants.map(u => u.id);
        const msgBody = message.message?.conversation || message.message?.extendedTextMessage?.text || '';
        const commandParts = msgBody.slice(1).trim().split(/\s+/);
        const text = commandParts.slice(1).join(' ') || 'Veuillez pr√™ter attention √† ce message distingu√©‚Ä¶';

        const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        if (quotedMsg) {
            if (quotedMsg.stickerMessage) {
                await client.sendMessage(jid, { sticker: quotedMsg.stickerMessage, mentions: participants });
            } else {
                const qText = quotedMsg.conversation || quotedMsg.extendedTextMessage?.text || '';
                await client.sendMessage(jid, { text: qText, mentions: participants });
            }
            return;
        }

        await client.sendMessage(jid, { text, mentions: participants });
    } catch (err) {
        console.error("Erreur lors de l'invocation g√©n√©rale :", err);
    }
}

// Fonctions settag et tagoption conserv√©es mais avec messages raffin√©s
export async function settag(message, client) {
    const jid = message.key.remoteJid;
    const number = client.user.id.split(':')[0];
    const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;

    if (!quotedMsg?.audioMessage) return client.sendMessage(jid, { text: 'Veuillez r√©pondre avec un message audio pour d√©finir la notification, s‚Äôil vous pla√Æt.' });

    try {
        const audioStream = await downloadMediaMessage({ message: quotedMsg }, "stream");
        const filePath = `${number}.mp3`;
        const writeStream = createWriteStream(filePath);

        if (!configManager.config.users[number]) configManager.config.users[number] = {};
        configManager.config.users[number].tagAudioPath = filePath;
        configManager.save();

        audioStream.pipe(writeStream);
        await client.sendMessage(jid, { text: 'Votre tag audio a √©t√© √©l√©gamment enregistr√©e. üé©' });
    } catch (err) {
        console.error("Erreur lors de la d√©finition du tag audio :", err);
    }
}

export async function tagoption(message, client) {
    const jid = message.key.remoteJid;
    const number = client.user.id.split(':')[0];
    const args = (message.message?.conversation || message.message?.extendedTextMessage?.text || '').slice(1).trim().split(/\s+/).slice(1);

    if (!configManager.config.users[number]) return;

    try {
        if (args.join(' ').toLowerCase().includes('on')) {
            configManager.config.users[number].response = true;
            configManager.save();
            await client.sendMessage(jid, { text: 'Les notifications automatiques ont √©t√© honorablement activ√©es. üé©' });
        } else if (args.join(' ').toLowerCase().includes('off')) {
            configManager.config.users[number].response = false;
            configManager.save();
            await client.sendMessage(jid, { text: 'Les notifications automatiques ont √©t√© poliment d√©sactiv√©es. üé©' });
        } else {
            await client.sendMessage(jid, { text: 'Veuillez choisir une option distingu√©e : on/off.' });
        }
    } catch (err) {
        console.error("Erreur lors du r√©glage des options de tag :", err);
    }
}

export default { tagall, tagadmin, tag, settag, tagoption };